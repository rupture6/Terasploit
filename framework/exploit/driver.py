# -*- coding: utf-8 -*-

# Python library
import socket
import threading
import time
from typing import Any

# Library
from lib.utils.printer import print_error, print_status
from lib.container.module import Module

# Framework
from framework.console.options import Opt
from framework.sessions.core.thread_handler import Session
from framework.sessions.core.connection_handler import (
    BindTCPHandler,
    ReverseTCPHandler
)


class DriverUtils:
    """ Utilities for exploit driver """

    @staticmethod
    def stop_bind_handler() -> None:
        """ Stop the bind TCP handler gracefully """
        Session.active_connector.set()
        while Session.handler_thread and Session.handler_thread.is_alive():
            time.sleep(0.5)
        Session.bind_tcp_reset()

    @staticmethod
    def finalize_bind_handler() -> None:
        """ Finalize bind handler and interact with the last session """
        DriverUtils.stop_bind_handler()
        DriverUtils.interact_with_session()

    @staticmethod
    def stop_reverse_handler(reset: bool = False) -> None:
        """ Stop the reverse TCP handler """
        try:
            Session.server_socket.shutdown(socket.SHUT_RDWR)
            Session.server_socket.close()
            Session.active_listener.set()
            while Session.handler_thread and Session.handler_thread.is_alive():
                time.sleep(0.1)
        except OSError:
            pass
        if reset:
            Session.reverse_tcp_reset()

    @staticmethod
    def interact_with_session() -> None:
        """ Interact with the most recent session """
        addr = Session.sessions[-1][1]
        print_status(f"Interacting with... {addr[0]}:{addr[1]}")
        exploit_session = Module.payload.info["Session"]
        exploit_session(Session.sessions[-1][0])


class ExploitDriver:
    """ Exploit driver for managing module execution and payload handlers """

    def __init__(self) -> None:
        handler_name = Module.payload.info.get("PayloadHandler") \
            if Module.payload else None

        if not handler_name:
            self.execute_exploit()
            return

        self.rhost = Opt.options["RHOST"]
        self.lhost = Opt.options["LHOST"]
        self.lport = Opt.options["LPORT"]

        handler = handler_name.lower()
        if handler == "reverse_tcp":
            self.reverse_handler()
        elif handler == "bind_tcp":
            self.bind_handler()
        else:
            raise NameError(f"Unknown payload handler: {handler_name}")

    def bind_handler(self) -> None:
        """ Initialize the bind TCP handler """
        payload_handler = BindTCPHandler(self.rhost, self.lport)
        try:
            Session.handler_thread = threading.Thread(
                target=payload_handler.start_handler, daemon=True
            )
            Session.handler_thread.start()
            time.sleep(0.5)

            result = self.execute_exploit()
            if result in {"failed", "error", "exception"}:
                if Session.sessions:
                    print_status(
                        "Exploit module done.",
                        f"Session created: {len(Session.sessions)}"
                    )
                if not Session.sessions:
                    print_status("Exploit module done. No session created.")
                DriverUtils.stop_bind_handler()
                return

            while not Session.sessions:
                time.sleep(0.5)

            DriverUtils.finalize_bind_handler()
        except KeyboardInterrupt:
            DriverUtils.stop_bind_handler()
            print_status("Interrupt signal... handler stopped...")

    def reverse_handler(self) -> None:
        """ Initialize the reverse TCP handler """
        payload_handler = ReverseTCPHandler(self.lhost, self.lport)
        try:
            Session.handler_thread = threading.Thread(
                target=payload_handler.start_handler, daemon=True
            )
            Session.handler_thread.start()
            time.sleep(0.5)

            result = self.execute_exploit()
            if result in {"failed", "error", "exception"}:
                if Session.sessions:
                    print_status(
                        "Exploit module done.",
                        f"Session created: {len(Session.sessions)}"
                    )
                if not Session.sessions:
                    print_status("Exploit module done. No session created.")
                DriverUtils.stop_reverse_handler(reset=True)
                return

            while not Session.sessions:
                try:
                    Session.server_socket.getsockname()
                except OSError:
                    break
                time.sleep(1)

            if not Session.sessions:
                DriverUtils.stop_reverse_handler(reset=True)
                return

            time.sleep(20.0)
            DriverUtils.stop_reverse_handler(reset=True)

            DriverUtils.interact_with_session()
        except KeyboardInterrupt:
            Session.active_listener.set()
            DriverUtils.stop_reverse_handler(reset=True)
            print_status("Interrupt signal... handler stopped...")

    @staticmethod
    def execute_exploit() -> Any | str:
        """Execute the current exploit module."""
        if not hasattr(Module.module, "exploit"):
            print_error("Current module doesn't have an exploit method.")
            return "error"

        return Module.module.exploit()
